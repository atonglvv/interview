# Socket是什么？

![](\img\net-layout.png)	

Socket 其实是在**「应用层与传输层之间的一个产物」**，它把传输层的很多复杂操作封装成一些简单的接口，来让应用层调用以此来实现进程在网络中的通信，Socket 是对端口通信开发的工具,它要更底层一些。



一次完整的网络通信必不可少的会经过物理传输层的网线和网卡，网络传输层的 IP 协议可以知道要将数据传送给哪台机器，但是在计算机系统中会运行不同进程，那要如何把**「网卡中的网络数据识别出来是给哪个进程的」**，这其实就是 Socket 设计的想解决的一点了。



# Socket 运行流程

## 基于TCP

![](img\stock-tcp.png)	

**Server**

- socket():表示创建一个 socket，底层会生成一个文件描述符，用来表示该 socket
- bind():用来绑定服务的端口，地址，这里一般都是以固定的为主，因为在客户端连接的时候需要指定
- listen():当绑定完成之后，listen 就会监听这个端口的数据包
- accept():相当于一个开关，表示我准备好了，可以接受请求了，但是这里会一直阻塞，直到客户端连接成功
- read():读取客户端发送过来的内容
- write():写入要返回的数据
- close():断开连接，**「四次挥手」**

**Client**

- socket():表示创建一个 socket，底层会生成一个文件描述符，用来表示该 socket
- connet():表示与指定地址进行连接，在此之前，会随机创建自己的端口，tcp 的**「三次握手就是从这里开始」**的
- write():客户端写入要发送的数据
- read():客户端读取服务端返回的数据
- close():断开连接，**「四次挥手」**，给客户端发送断开连接的信息

## 基于UDP



![](\img\stock-udp.png)	

因为 UDP 是无状态的，所以对于服务端来说没有连接，并且其会在调用 Recvfrom() 方法后就收客户端的请求，并一直阻塞，直到收到信息。



# 三次握手发生在 socket 的哪几个函数中

![](img\stock-three-handshake.png)	

当客户端调用 connect 时，触发了连接请求，向服务器发送了SYN 信号，这时 connect 进入阻塞状态。

服务器监听到连接请求，即收到 SYN，调用 accept 函数接收，进入阻塞状态，在此之前会尽力 socket、bind、listen 函数；然后返回相关的 syn 以及 ack 信号。

客户端接受到服务端的信息，此时 connect 完成，解除阻塞状态，并且向服务端发送 ack 信号。

服务端收到 ack， accept 阻塞解除，完成连接。

在建立连接之后，connect() 就已经执行完毕了，服务端就可以向客户端发送数据了。



















