# 对称加密？

加密和解密使用的是同一个秘钥。

# 非对称加密？

非对称加密需要用两个秘钥来进行加密和解密。



# https

考虑场景一：

client 跟 server用对称加密，client请求server，server返回给client一个密钥。

后面client使用该密钥进行加密解密，跟server交流。

问题：

client第一次请求server的时候，采用的是明文。如果该请求被拦截，就会造成密钥泄漏。



考虑场景二：

client请求server，server首先将自己的公钥发给client。

client收到公钥后，client自己也生成一个密钥k3（对称加密用）。

并且用公钥k1对自己生成的密钥k3加密，发送给server。

server使用自己的私钥k2，解开密文，获取k3。

然后 client 跟 server 通过k3进行对称加密的通信。

问题：

考虑黑客，可以截获第一次请求server发给client的公钥。

黑客可以将自己生成的公钥k4发给client。

client使用公钥k4加密自己的密钥k3。并发送给server。

请求再次被黑客截获，黑客可以使用自己的私钥k5解密client发送的内容获取k3。

这样黑客就获取到了client跟server之间的对称加密的密钥。



考虑场景三：

server首先把自己的公钥K1发给证书颁发机构，向证书颁发机构申请证书。

证书颁发机构自己也有一对公钥私钥。机构利用自己的私钥来加密K1，并且通过服务端网址等信息生成一个证书签名，证书签名同样经过机构的私钥加密。证书制作完成后，机构把证书发送给了server。

当client向server请求通信的时候，server不再直接返回自己的公钥K1，而是把自己申请的证书返回给client。

client收到证书以后，要做的第一件事情是验证证书的真伪。需要说明的是，**各大浏览器和操作系统已经维护了所有权威证书机构的名称和公钥**。所以client只需要知道是哪个机构颁布的证书，就可以从本地找到对应的机构公钥，解密出证书签名。

接下来，client按照同样的签名规则，自己也生成一个证书签名，如果两个签名一致，说明证书是有效的。

验证成功后，client就可以放心地再次利用机构公钥，解密出server的公钥K1。

client用公钥k1对自己生成的密钥k3加密，发送给server。

server使用自己的私钥k2，解开密文，获取k3。

然后 client 跟 server 通过k3进行对称加密的通信。



