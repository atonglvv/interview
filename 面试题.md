一面：
#Java如何序列化的？序列化的作用是什么？
Java中的序列化机制能够将一个实例对象（只序列化对象的属性值，而不会去序列化方法。）的状态信息写入到一个字节流中，通过实现Serializable接口
作用：
1.把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；
2.在网络上传送对象的字节序列。

#arraylist 哪一块线程不安全？
add(e)方法

#arraylist 扩容机制
默认容量10，添加到第11个元素时，复制一个新数组，为旧数组的容量的1.5倍，将原数据复制过来

#线程安全的arraylist有什么？
使用Vector容器
使用Collections的静态方法synchronizedList(List< T> list)
采用CopyOnWriteArrayList容器

#jvm内存结构
堆、虚拟机栈、本地方法栈、方法区（1.7及之前对方法区的实现是永久代，1.8及之后是元空间）、程序计数器

#cms垃圾收集原理
基于标记-清除算法实现，四个步骤，初始标记、并发标记、重写标记、并发清除

#栈上分配
栈上分配是jvm的一个优化技术，对于那些线程私有的对象，可以将它们分配在栈上，而不是堆上。栈上分配的好处是可以在函数调用后自行销毁，而不是GC介入，从而提升了系统的性能。
    为了减少临时对象在堆内分配的数量，会在一个方法体内定义一个局部变量，并且该变量在方法执行过程中未发生逃逸，
按照JVM调优机制，首先会在堆内存创建类的实例，然后将此对象的引用压入调用栈，继续执行，这是JVM优化前的方式。
然后，我采用逃逸分析对JVM进行优化。即针对栈的重新分配方式，首先找出未逃逸的变量，将该变量直接存到栈里，
无需进入堆，分配完成后，继续调用栈内执行，最后线程执行结束，栈空间被回收，局部变量也被回收了。
如此操作，是优化前在堆中，优化后在栈中，从而减少了堆中对象的分配和销毁，从而优化性能。

#逃逸分析
逃逸分析，是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。通过逃逸分析，Java Hotspot编译器能够分析出一个新的对象的引用的使用范围从而决定是否要将这个对象分配到堆上。

#指针碰撞跟内存列表

#垃圾回收算法
复制
标记整理
标记清除

#多线程跟jvm之间的关系

#aqs原理

#aqs为什么维护了一个双向链表。单向链表可以me？

#@CountDownLatch用过么？

#cas原理
CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。

#cas有什么问题？怎么解决？
ABA 、版本号

#数据库的聚簇索引跟非聚簇索引

#innodb的数据结构
B+TREE

#复合索引的叶子结点存储方式
键值是排好序的B+tree

#最左前缀匹配原则
联合索引的顺序

#叶子结点的数据结构是什么？

#redis删除过期键策略
1.定时
2.惰性
3.定期

#缓存穿透 缓存击穿 缓存血崩
查询不存在的key，不存在的key设置空值（过期时间短一些）、布隆过滤器
缓存过期后，同时有大量请求查询这个key，互斥锁、永不过期
大量key同时过期，设置不同的过期时间、读db加锁或读操作放入队列

#kafka为什么有副本这个东西？

spring bean的生命周期
spring bean实例化的方式有几种？什么设计模式？
类构造方法实例化
工厂类静态方法实例化
工厂类普通方法实例化


xxl-job的源码有没有看过？

二面[项目经理面]：
#数据库的隔离级别
read uncommited：读未提交。（脏读）
read committed ：读已提交。（不可重复读）
repeatable read：可重复读。（幻读）
serializable 串行化

#innodb如何解决幻读的？
快照读，使用mvcc解决
当前读，使用临键锁解决

#说一下mvcc

说一下你对kafka的理解
#dubbo有哪几种通信协议？你们用的哪种？
【dubbo】rmi、webservice、http、hessian、memcache、redis

#dubbo的序列化默认是哪一种？
默认使用 Hessian 序列化，还有 duddo、FastJson、Java 自带序列化。

dubbo是怎么进行通信的？

