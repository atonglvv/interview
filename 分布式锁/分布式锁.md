>[Redis分布式锁保姆级无死角分析](https://mp.weixin.qq.com/s/RViDM1WHE61SDLNKzUmTAg)

# 分布式锁实现方式

MySQL lock，for update。record lock

MySQL 乐观锁。version。update stock > 0。

Redis

Zookeeper

# 如何选型

| 实现方式  | 优点                                                         | 缺点                                                         | 应用场景                           |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------- |
| MySQL     | 实现简单                                                     | 性能最低，吞吐低                                             | 适用于并发量低，性能要求低的场景。 |
| Redis     | 性能高，无单点故障                                           | 存在一致性问题                                               | 适用于高并发场景                   |
| Zookeeper | 可靠性高。<br />不需要考虑锁的过期时间。<br />watch 机制，加锁失败，可以 watch 等待锁释放，实现乐观锁。 | 性能低于Redis。<br />部署与运维成本高。<br />存在客户端与 Zookeeper 的长时间失联，锁被释放问题。 | 适用于大部分分布式场景             |



# Zookeeper分布式锁

利用 zookeeper 的同级节点的唯一性特性，在需要获取排他锁时，所有的客户端试图通过调用 create() 接口，在 **/exclusive_lock** 节点下创建临时子节点 **/exclusive_lock/lock**，最终只有一个客户端能创建成功，那么此客户端就获得了分布式锁。同时，所有没有获取到锁的客户端可以在 **/exclusive_lock** 节点上注册一个子节点变更的 watcher 监听事件，以便重新争取获得锁。

Zookeeper 不像 Redis 那样，需要考虑锁的过期时间问题，它是采用了「临时节点」，保证客户端拿到锁后，只要连接不断，就可以一直持有锁。



1.客户端1调用create()方法创建名为"/业务ID/lock-"的临时顺序节点。

2.客户端1调用getChildren("业务ID")方法来获取所有已经创建的子节点。

3.客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点是所有节点中序号最小的，就是看自己创建的序列号是否排第一，如果是第一，那么就认为这个客户端获得了锁，在它前面没有别的客户端拿到锁。

4.如果创建的节点不是所有节点中需要最小的，那么则监视比自己创建节点的序列号小的最大的节点，进入等待。直到下次监视的子节点变更的时候，再进行子节点的获取，判断是否获取锁。





