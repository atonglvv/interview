>[Redis分布式锁保姆级无死角分析](https://mp.weixin.qq.com/s/RViDM1WHE61SDLNKzUmTAg)

# 分布式锁实现方式

MySQL lock，for update。record lock

MySQL 乐观锁。version。update stock > 0。

Redis

Zookeeper

# 如何选型

| 实现方式  | 优点                                                         | 缺点                                                         | 应用场景                           |
| --------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------- |
| MySQL     | 实现简单                                                     | 性能最低，吞吐低                                             | 适用于并发量低，性能要求低的场景。 |
| Redis     | 性能高，无单点故障                                           | 存在一致性问题                                               | 适用于高并发场景                   |
| Zookeeper | 可靠性高。<br />不需要考虑锁的过期时间。<br />watch 机制，加锁失败，可以 watch 等待锁释放，实现乐观锁。 | 性能低于Redis。<br />部署与运维成本高。<br />存在客户端与 Zookeeper 的长时间失联，锁被释放问题。 | 适用于大部分分布式场景             |



# Zookeeper分布式锁

利用 zookeeper 的同级节点的唯一性特性，在需要获取排他锁时，所有的客户端试图通过调用 create() 接口，在 **/exclusive_lock** 节点下创建临时子节点 **/exclusive_lock/lock**，最终只有一个客户端能创建成功，那么此客户端就获得了分布式锁。同时，所有没有获取到锁的客户端可以在 **/exclusive_lock** 节点上注册一个子节点变更的 watcher 监听事件，以便重新争取获得锁。

Zookeeper 不像 Redis 那样，需要考虑锁的过期时间问题，它是采用了「临时节点」，保证客户端拿到锁后，只要连接不断，就可以一直持有锁。



1.客户端1调用create()方法创建名为"/业务ID/lock-"的临时顺序节点。

2.客户端1调用getChildren("业务ID")方法来获取所有已经创建的子节点。

3.客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点是所有节点中序号最小的，就是看自己创建的序列号是否排第一，如果是第一，那么就认为这个客户端获得了锁，在它前面没有别的客户端拿到锁。

4.如果创建的节点不是所有节点中需要最小的，那么则监视比自己创建节点的序列号小的最大的节点，进入等待。直到下次监视的子节点变更的时候，再进行子节点的获取，判断是否获取锁。



# zookeeper和Redis做分布式锁的比较

## Reids

Redis只保证最终一致性，副本间的数据复制是异步进行(Reids集群一般是读写分离架构，存在主从同步延迟情况)。主节点宕机，主从切换之后可能有部分数据没有复制过去可能会导致**丢失锁**情况，故强一致性要求的业务不推荐使用redis，推荐使用zk。

Redis响应时间非常低。随着并发量和业务数量的提升其响应时间会有明显上升(公网集群影响因素偏大)，但是极限QPS可以达到最大且基本无异常。

## zooKeeper

使用ZooKeeper集群，锁原理是使用ZooKeeper的临时顺序节点，临时顺序节点的生命周期在Client与集群的Session结束时结束。因此如果某个Client节点存在网络问题，与ZooKeeper集群断开连接，Session超时同样会导致锁被错误的释放（导致被其他线程错误地持有)，因此ZooKeeper也无法保证完全一致。

ZK具有较好的稳定性。响应时间抖动很小，没有出现异常。但是随着并发显和业务数显的提升其响应时间和QPS会明显下降。

Zookeeper每次进行锁操作前都要创建若干节点，完成后要释放节点，会浪费很多时间。而且需要集群间的同步，来保证一致性，效率相比redis低。