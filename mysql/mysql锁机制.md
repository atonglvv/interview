# MySQL锁，锁的到底是什么？

## 锁与事务的关系

事务有`A`（原子性）、`C`（一致性）、`I`（隔离性）、`D`（持久性）4大特性，而锁就是实现隔离性的其中一种方案（比如还有MVCC等方案）。

事务的隔离性针对不同场景需求又实现了不同的隔离级别，不同的隔离级别下，事务使用锁的方式又会有所不同。举个例子。

在`READ COMMITTED`、`REPEATABLE READ`这两种隔离级别之下，`SELECT`操作是不需要加锁的，直接使用MVCC机制即可满足当前隔离级别的需求。但是在`SERIALIZABLE`隔离级别，并且在禁用自动提交时（autocommit=0），MySQL会将普通的`SELECT`语句转化为`SELECT ... LOCK IN SHARE MODE`这样的加锁语句，如果你看不懂这句话也没关系，你只需要知道MySQL自动加锁了就行，更详细的下文再说。

另外，一个事务可能会加很多个锁，但是某个锁一定只属于一个事务。这就好比一个管理员可以管理多个保险柜，一个保险柜一定只被一个管理员管理。

## 锁的粒度

举一个非常应景的例子。疫情防控的时候，是封锁整个小区还是封锁某栋楼的某个单元，这完全是两种概念。

对应到MySQL锁的粒度，那就是`表锁`和`行锁`。

很容易想到，封锁小区的行为远比封锁某栋楼某单元的行为粗旷，因此，

**从锁定粒度上来看，表锁 > 行锁**

直接堵住小区的门口要比进入小区找到具体某栋楼的某个单元要快不少，因此，

**从加锁效率上来看，表锁 > 行锁**

直接锁住小区大概率会影响其他楼居民的正常生活和各种社会活动的开展，而锁住某栋楼某单元顶多影响这一个单元的居民的生活，因此，

**从冲突概率来看，表锁 > 行锁**

**从并发性能来看，表锁 < 行锁**

MySQL支持很多存储引擎，而不同的存储引擎对锁的支持也不尽相同。对于`MyISAM`、`MERGE`、`MEMORY`这些存储引擎而言，只支持表锁；而`InnoDB`存储引擎既支持表锁也支持行锁，下文讨论的所有内容均针对InnoDB存储引擎。

说完锁的粒度，还有一件事情需要我们仔细考虑一下。上文说过，`READ COMMITTED`、`REPEATABLE READ`这两种隔离级别之下，`SELECT`操作默认采用MVCC机制就可以了，压根儿不需要加锁，那么问题来了，万一我就是想加锁呢？

你可能会说，“简单啊，那就加锁！把数据锁死！除了我谁也别动！”

很好，但是对于大部分读—读而言，由于不会出现读一致性问题，所以不让其他事务进行读操作并不合理。

你可能又说，“那行吧，那就让读操作加锁的时候允许其他事务对锁住的数据进行读操作，但是不允许写操作。”

嗯，想得确实更细致了一些。但是再想想我上文中举过的陀螺存钱的例子，有时候`SELECT`操作需要独占数据，其他事务既不能读，更不能写。

我们把这种**共享**和**排他**的性质称为锁的基本模式。

## **锁的基本模式**

### 共享锁

共享锁（Shared Lock），简称`S`锁，可以同时被多个事务共享，也就是说，如果一个事务给某个数据资源添加了`S`锁，其他事务也被允许获取该数据资源的`S`锁。

由于`S`锁通常被用于读取数据，因此也被称为**读锁**。

那怎么给数据添加`S`锁呢？

我们可以用 `SELECT ... LOCK IN SHARE MODE; `的方式，在读取数据之前就为数据添加一把`S`锁。如果当前事务执行了该语句，那么会为读取到的记录添加`S`锁，同时其他事务也可以使用`SELECT ... LOCK IN SHARE MODE; `方式继续获取这些数据的`S`锁。

### 排他锁

排他锁（Exclusive Lock），简称`X`锁。只要一个事务获取了某数据资源的`X`锁，其他的事务就不能再获取该数据的`X`锁和`S`锁。

由于`X`锁通常被用于修改数据，因此也被称为**写锁**。

`X`锁的添加方式有两种，

1. 自动添加`X`锁

   我们对记录进行增删改时，通常情况下会自动对其添加`X`锁。

2. 手动加锁

   我们可以用 `SELECT ... FOR UPDATE; `的方式，在读取数据之前就为数据添加一把`X`锁。如果当前事务执行了该语句，那么会为读取到的记录添加`X`锁，这样既不允许其他事务获取这些记录的`S`锁，也不允许获取这些记录的`X`锁。

### 意向锁

前面提到的`S`锁和`X`锁的语法规则其实是针对记录的，也就是行锁，原因是InnoDB中行锁用的最多。如果将锁的粒度和锁的基本模式排列组合一下，就会出现如下4种情况：

- 行级`S`锁
- 行级`X`锁
- 表级`S`锁
- 表级`X`锁

那么接下来的描述，也就顺理成章了。

如果事务给一个表添加了表级`S`锁，则：

- 其他事务可以继续获得该表的`S`锁，但是无法获取该表的`X`锁；
- 其他事务可以继续获得该表某些行的`S`锁，但是无法获取该表某些行的`X`锁。

如果事务给一个表添加了表级`X`锁，则：

- 不论是该表的`S`锁、`X`锁，还是该表某些行的`S`锁、`X`锁，其他事务都只能干瞪眼儿，啥也获取不了。

挺好理解的吧，总之就是**S锁只能和S锁相容，X锁和其他任何锁都互斥**。问题来了，虽然用的不多，但是万一我真的想给整个表添加一个`S`锁或者`X`锁怎么办？

假如我要给表`user`添加一个`S`锁，那就必须保证`user`在表级别上和行级别上都不能有`X`锁，表级别上还好说一点，无非就是1个内存结构罢了，但是行`X`锁呢？必须得逐行遍历是否有行`X`锁吗？

同理，假如我要给表`user`添加一个`X`锁，那就必须保证`user`在表级别上和行级别上都不能有任何锁（`S`和`X`都不能有），难不成得逐行遍历是否有`S`或`X`锁吗？

遍历是不可能遍历的！这辈子都不可能遍历的！于是，**意向锁**（Intension Lock）诞生了。

我们要避免遍历，那最好的办法就是在给行加锁时，先在表级别上添加一个标识。

- 意向共享锁（Intension Shared Lock）：简称`IS`锁，当事务试图给行添加`S`锁时，需要先在表级别上添加一个`IS`锁；
- 意向排他锁（Intension Exclusive Lock）：简称`IX`锁，当事务试图给行添加`X`锁时，需要先在表级别上添加一个`IX`锁。

这样一来：

- 如果想给`user`表添加一个`S`锁（表级锁），就先看一下`user`表有没有`IX`锁；如果有，就说明`user`表的某些行被加了`X`锁（行锁），需要等到行的`X`锁释放，随即`IX`锁被释放，才可以在`user`表中添加`S`锁；
- 如果想给`user`表添加一个`X`锁（表级锁），就先看一下`user`有没有`IS`锁或`IX`锁；如果有，就说明`user`表的某些行被加了`S`锁或`X`锁（行锁），需要等到所有行锁被释放，随即`IS`锁或`IX`锁被释放，才可以在`user`表中添加`X`锁。

> 需要注意的是，意向锁和意向锁之间是不冲突的，意向锁和行锁之间也不冲突。
>
> 只有在对表添加`S`锁或`X`锁时才需要判断当前表是否被添加了`IS`锁或`IX`锁，当为表添加`IS`锁或`IX`锁时，不需要关心当前表是否已经被添加了其他`IS`锁或`IX`锁。

目前为止MySQL锁的基本模式就介绍完了，接下来回到这片文章的题目，MySQL锁，锁住的到底是什么？由于InnoDB的行锁用的最多，这里的锁自然指的是行锁。

## 行锁的原理

**InnoDB的行锁并非直接锁定Record行**。

行锁锁住的既不是Record行，也不是Column列，那到底锁住的是什么？其实**InnoDB的行锁，就是通过锁住索引来实现的**。

### 锁住索引？没有索引怎么办？

如果我们没有设置主键，InnoDB会优先选取一个不包含NULL值的`Unique键`作为主键，如果表中连`Unique键`也没有的话，就会自动为每一条记录添加一个叫做`DB_ROW_ID`的列作为默认主键，只不过这个主键我们看不到罢了。

### 为什么通过唯一索引给数据加锁，主键索引也会被锁住？

不管是`Unique`索引还是普通索引，它们的叶子结点中存储的数据都不完整，其中只是存储了作为索引并且排序好的列数据以及对应的主键值。

因此我们通过索引查找数据数据实际上是在索引的B+树中先找到对应的主键，然后根据主键再去主键索引的B+树的叶子结点中找到完整数据，最后返回。所以虽然是两个索引树，但实际上是同一行数据，必须全部锁住。

下面给了一张图，让不了解索引的朋友大致了解一下。上半部分是`name`列创建的唯一索引的B+树，下半部分是主键索引（也叫聚簇索引）。

假如我们通过`WHERE name = '王钢蛋'`对数据进行查询，会先用到`name`列的唯一索引，最终定位到主键值为`1`，然后再到主键索引中查询`id = 1`的数据，最终拿到完整的行数据。



## 总结





