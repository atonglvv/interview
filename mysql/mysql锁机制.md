# MySQL锁，锁的到底是什么？

## 分类（粒度）

MySQL中的锁，按照锁的粒度分，分为以下三类:

- 全局锁：锁定数据库中的所有表。

- 表级锁：每次操作锁住整张表。

- 行级锁：每次操作锁住对应的行数据。

**从冲突概率来看，全局锁 > 表锁 > 行锁**

**从并发性能来看，全局锁 < 表锁 < 行锁 **

对于`MyISAM`、`MERGE`、`MEMORY`这些存储引擎而言，只支持表锁；

而`InnoDB`存储引擎既支持表锁也支持行锁，下文讨论的所有内容均针对InnoDB存储引擎。

## 全局锁

全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的DML的写语句，DDL语句，已及更新操作的事务提交语句都将被阻塞。

其典型的使用场景是做全库的逻辑备份，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。

```sql
 -- 添加全局锁的命令
 flush tables with read lock;

 # 数据库备份命令, 说明：-h和-P默认就是本地IP和3306端口
 mysqldump [-h127.0.0.1 -P3306] -uroot –p1234 itcast > D:/itcast.sql
 
  -- 全局锁解锁
 unlock tables ;
```

全局锁的问题？

数据库中加全局锁，是一个比较重的操作，存在以下问题：

- 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆；

- 如果我们的数据库不是单机版的，而是主从结构，而且还做了读写分离，这时在写入操作的时候是不会阻塞的，因为我们是写入主库;我们可以从从库上进行备份，但在备份期间从库不能执行主库同步过来的二进制日志（binlog），会导致主从延迟；

**解决方案：**

在InnoDB引擎中，我们可以在备份时加上参数` --single-transaction` 参数来完成不加锁的一致性数据备份：

```sql
 mysqldump --single-transaction -uroot –p1234 itcast > itcast.sql
```

## 表级锁

对于表级锁，主要分为以下三类: 表锁、元数据锁（ meta data lock，MDL)、意向锁。

### **显式表锁**

分为共享锁（S）和排他锁（X）

显式加锁方式：**lock tables ... read/write**

释放锁：**unlock tables**(连接中断也会自动释放)

### **Metadata-Lock** **（元数据锁）**

MySQL5.5版本开始引入，主要功能是并发条件下，防止session1的查询事务未结束的情况下，session2对表结构进行修改，保护元数据的一致性。

### Intention Locks（意向锁）

**意向锁**为表锁（表示为IS或者IX），由存储引擎自己维护，用户无法干预。

下面举一个例子说明其功能。假设有2个事务：T1和T2

**T1:** 锁住表中的一行，只能读不能写（行级读锁）。

**T2:** 申请整个表地写锁（表级写锁）。

如T2申请成功，则能任意修改表中的一行，但这与T1持有的行锁是冲突的。故数据库应识别这种冲突，让T2的锁申请被阻塞，直到T1释放行锁。

有2种方法可以实现冲突检测：

1、判断表是否已被其他事务用表锁锁住；

2、判断表中的每一行是否已被行锁锁住。

其中2需要遍历整个表，效率太低。因此 innodb 使用意向锁来解决这个问题：T1需要先申请表的意向共享锁（IS），成功后再申请某一行的记录锁S。

在意向锁存在的情况下，上面的判断可以改为：T2发现表上有意向共享锁IS，因此申请表地写锁被阻塞。

## 行锁

MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。

**InnoDB的行锁并非直接锁定Record行**。

行锁锁住的既不是Record行，也不是Column列，那到底锁住的是什么？其实**InnoDB的行锁，就是通过锁住索引来实现的**。

### 锁住索引？没有索引怎么办？

如果我们没有设置主键，InnoDB会优先选取一个不包含NULL值的`Unique键`作为主键，如果表中连`Unique键`也没有的话，就会自动为每一条记录添加一个叫做`DB_ROW_ID`的列作为默认主键，只不过这个主键我们看不到罢了。

### 为什么通过唯一索引给数据加锁，主键索引也会被锁住？

不管是`Unique`索引还是普通索引，它们的叶子结点中存储的数据都不完整，其中只是存储了作为索引并且排序好的列数据以及对应的主键值。

因此我们通过索引查找数据数据实际上是在索引的B+树中先找到对应的主键，然后根据主键再去主键索引的B+树的叶子结点中找到完整数据，最后返回。所以虽然是两个索引树，但实际上是同一行数据，必须全部锁住。

下面给了一张图，让不了解索引的朋友大致了解一下。上半部分是`name`列创建的唯一索引的B+树，下半部分是主键索引（也叫聚簇索引）。

假如我们通过`WHERE name = '王钢蛋'`对数据进行查询，会先用到`name`列的唯一索引，最终定位到主键值为`1`，然后再到主键索引中查询`id = 1`的数据，最终拿到完整的行数据。



## 锁与事务的关系

事务有`A`（原子性）、`C`（一致性）、`I`（隔离性）、`D`（持久性）4大特性，而锁就是实现隔离性的其中一种方案（比如还有MVCC等方案）。

事务的隔离性针对不同场景需求又实现了不同的隔离级别，不同的隔离级别下，事务使用锁的方式又会有所不同。举个例子。

在`READ COMMITTED`、`REPEATABLE READ`这两种隔离级别之下，`SELECT`操作是不需要加锁的，直接使用MVCC机制即可满足当前隔离级别的需求。但是在`SERIALIZABLE`隔离级别，并且在禁用自动提交时（autocommit=0），MySQL会将普通的`SELECT`语句转化为`SELECT ... LOCK IN SHARE MODE`这样的加锁语句，如果你看不懂这句话也没关系，你只需要知道MySQL自动加锁了就行，更详细的下文再说。

另外，一个事务可能会加很多个锁，但是某个锁一定只属于一个事务。这就好比一个管理员可以管理多个保险柜，一个保险柜一定只被一个管理员管理。

## **锁的基本模式**

### 共享锁

共享锁（Shared Lock），简称`S`锁，可以同时被多个事务共享，也就是说，如果一个事务给某个数据资源添加了`S`锁，其他事务也被允许获取该数据资源的`S`锁。

由于`S`锁通常被用于读取数据，因此也被称为**读锁**。

那怎么给数据添加`S`锁呢？

我们可以用 `SELECT ... LOCK IN SHARE MODE; `的方式，在读取数据之前就为数据添加一把`S`锁。如果当前事务执行了该语句，那么会为读取到的记录添加`S`锁，同时其他事务也可以使用`SELECT ... LOCK IN SHARE MODE; `方式继续获取这些数据的`S`锁。

### 排他锁

排他锁（Exclusive Lock），简称`X`锁。只要一个事务获取了某数据资源的`X`锁，其他的事务就不能再获取该数据的`X`锁和`S`锁。

由于`X`锁通常被用于修改数据，因此也被称为**写锁**。

`X`锁的添加方式有两种，

1. 自动添加`X`锁

   我们对记录进行增删改时，通常情况下会自动对其添加`X`锁。

2. 手动加锁

   我们可以用 `SELECT ... FOR UPDATE; `的方式，在读取数据之前就为数据添加一把`X`锁。如果当前事务执行了该语句，那么会为读取到的记录添加`X`锁，这样既不允许其他事务获取这些记录的`S`锁，也不允许获取这些记录的`X`锁。

### 意向锁

前面提到的`S`锁和`X`锁的语法规则其实是针对记录的，也就是行锁，原因是InnoDB中行锁用的最多。如果将锁的粒度和锁的基本模式排列组合一下，就会出现如下4种情况：

- 行级`S`锁
- 行级`X`锁
- 表级`S`锁
- 表级`X`锁

那么接下来的描述，也就顺理成章了。

如果事务给一个表添加了表级`S`锁，则：

- 其他事务可以继续获得该表的`S`锁，但是无法获取该表的`X`锁；
- 其他事务可以继续获得该表某些行的`S`锁，但是无法获取该表某些行的`X`锁。

如果事务给一个表添加了表级`X`锁，则：

- 不论是该表的`S`锁、`X`锁，还是该表某些行的`S`锁、`X`锁，其他事务都只能干瞪眼儿，啥也获取不了。

挺好理解的吧，总之就是**S锁只能和S锁相容，X锁和其他任何锁都互斥**。问题来了，虽然用的不多，但是万一我真的想给整个表添加一个`S`锁或者`X`锁怎么办？

假如我要给表`user`添加一个`S`锁，那就必须保证`user`在表级别上和行级别上都不能有`X`锁，表级别上还好说一点，无非就是1个内存结构罢了，但是行`X`锁呢？必须得逐行遍历是否有行`X`锁吗？

同理，假如我要给表`user`添加一个`X`锁，那就必须保证`user`在表级别上和行级别上都不能有任何锁（`S`和`X`都不能有），难不成得逐行遍历是否有`S`或`X`锁吗？

遍历是不可能遍历的！这辈子都不可能遍历的！于是，**意向锁**（Intension Lock）诞生了。

我们要避免遍历，那最好的办法就是在给行加锁时，先在表级别上添加一个标识。

- 意向共享锁（Intension Shared Lock）：简称`IS`锁，当事务试图给行添加`S`锁时，需要先在表级别上添加一个`IS`锁；
- 意向排他锁（Intension Exclusive Lock）：简称`IX`锁，当事务试图给行添加`X`锁时，需要先在表级别上添加一个`IX`锁。

这样一来：

- 如果想给`user`表添加一个`S`锁（表级锁），就先看一下`user`表有没有`IX`锁；如果有，就说明`user`表的某些行被加了`X`锁（行锁），需要等到行的`X`锁释放，随即`IX`锁被释放，才可以在`user`表中添加`S`锁；
- 如果想给`user`表添加一个`X`锁（表级锁），就先看一下`user`有没有`IS`锁或`IX`锁；如果有，就说明`user`表的某些行被加了`S`锁或`X`锁（行锁），需要等到所有行锁被释放，随即`IS`锁或`IX`锁被释放，才可以在`user`表中添加`X`锁。

> 需要注意的是，意向锁和意向锁之间是不冲突的，意向锁和行锁之间也不冲突。
>
> 只有在对表添加`S`锁或`X`锁时才需要判断当前表是否被添加了`IS`锁或`IX`锁，当为表添加`IS`锁或`IX`锁时，不需要关心当前表是否已经被添加了其他`IS`锁或`IX`锁。

目前为止MySQL锁的基本模式就介绍完了，接下来回到这片文章的题目，MySQL锁，锁住的到底是什么？由于InnoDB的行锁用的最多，这里的锁自然指的是行锁。



## 总结





