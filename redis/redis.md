# 为什么要用缓存？

高性能：缓存快

高并发：MySQL也就2000QPS，缓存可以支持十几万QPS

# 什么是缓存预热？

缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。避免用户请求的时候， 先查询数据库，然后再将数据缓存的问题！

# 用缓存后有什么问题？

数据库与缓存的一致性问题

缓存会有击穿、穿透、雪崩的问题

# redis除了做缓存，还能做什么？

- 分布式锁
- 限流：redis+Lua
- 消息队列
- 复杂业务场景：统计活跃用户（bitmap），排行榜（sorted set）

# redis 的线程模型

**Redis 基于 Reactor 模式（Netty的线程模型也是基于Reactor模式）来设计开发了自己的一套高效的事件处理模型** 。

redis的文件事件处理器（file event handler）是单线程方式运行的，所以一般我们都说Redis是单线程模型。

# 为什么之前的redis是单线程也能有这么高的效率？

Redis 通过**IO 多路复用程序** 监听来自客户端的大量连接（或者说是监听多个 socket）。

这样的好处非常明显： **I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗**（和 NIO 中的 `Selector` 组件很像）。

高效的数据存储结构。

# redis6.0之前为什么不用多线程？

- 单线程编程容易并且更容易维护；
- Redis 的性能瓶颈不在 CPU ，主要在内存和网络；
- 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。

# redis 为什么后面引入了多线程？

**Redis6.0 引入多线程主要是为了提高网络 IO 读写性能**。Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此不需要担心线程安全问题。

Redis6.0 的多线程默认是禁用的，只使用主线程。

# 为什么redis这么快？

IO多路复用

内存

单线程不需要处理并发问题，不需要线程切换

数据结构简单

# Redis 与 memcached 相比有哪些优势？

memcached 所有的值均是简单的字符串，redis 作为其替代者，支持更为丰富的数据类型。

redis 的速度比 memcached 快很多。

redis 可以持久化其数据。

Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的IO复用模型。

# Redis的数据类型

## redis 有哪些数据类型？

Strings

Hashes

Lists

Sets

Sorted Sets

Redis 除了这 5 种数据类型之外，还有 Bitmaps、HyperLogLogs、 geospatial indexes  、Streams 等。

​	![](img\数据类型与数据结构.png)

## SDS简单动态字符串

​	![](img\sds.png)

- 字符串长度处理：Redis获取字符串长度，时间复杂度为O(1)，而C语言中，需要从头开始遍历，复杂度为O（n）;
- 空间预分配：字符串修改越频繁的话，内存分配越频繁，就会消耗性能，而SDS修改和空间扩充，会额外分配未使用的空间，减少性能损耗。当对一个SDS进行修改，并且需要对SDS进行空间扩展的时候，程序不仅会为SDS分配修改所必须的空间，还会为SDS分配额外的未使用的空间。
- 惰性空间释放：SDS 缩短时，不是回收多余的内存空间，而是free记录下多余的空间，后续有变更，直接使用free中记录的空间，减少分配。

## 字典（map）

Redis 作为 K-V 型内存数据库，所有的键值就是用字典来存储。字典就是哈希表，比如HashMap，通过key就可以直接获取到对应的value。而哈希表的特性，在O（1）时间复杂度就可以获得对应的值。

## 跳跃表（skiplist）

​	![](img\skiplist.png)

- 跳跃表是Redis特有的数据结构，就是在链表的基础上，增加多级索引提升查找效率。
- 跳跃表支持平均 O（logN）,最坏 O（N）复杂度的节点查找，还可以通过顺序性操作批量处理节点。

## 合理的数据编码

Redis 支持多种数据类型，每种基本类型，可能对多种数据结构。什么时候,使用什么样数据结构，使用什么样编码，是redis设计者总结优化的结果。

- String：如果存储数字的话，是用int类型的编码;如果存储非数字，小于等于39字节的字符串，是embstr；大于39个字节，则是raw编码。
- List：如果列表的元素个数小于512个，列表每个元素的值都小于64字节（默认），使用ziplist编码，否则使用linkedlist编码
- Hash：哈希类型元素个数小于512个，所有值小于64字节的话，使用ziplist编码,否则使用hashtable编码。
- Set：如果集合中的元素都是整数且元素个数小于512个，使用intset编码，否则使用hashtable编码。
- Zset：当有序集合的元素个数小于128个，每个元素的值小于64字节时，使用ziplist编码，否则使用skiplist（跳跃表）编码



# redis 的常用命令

- keys * ：查看当前数据库中所有的key
- dbsize： 键总数
- exists key： 检查键是否存在
- del key [key …]： 删除键
- persist key： 移除键的过期时间
- type key： 键的数据结构类型
- set key value： 设置一个key的value值
- setnx key value： 仅当key不存在时进行set
- setex key seconds value： set 键值对并设置过期时间
- get key： 返回key的value
- mget key [key …] ： 批量获取多个key保存的值
- exists key [key …]： 查询一个key是否存在
- decr/incr key： 将指定key的value数值进行+1/-1(仅对于数字)
- incrby/decrbyB key n： 按指定的步长对数值进行加减
- **Lists 添加操作**
- lpush/rpush key value1[value2…]： 从左边/右边向列表中PUSH值(一个或者多个)
- lpushx/rpushx key value： 向已存在的列名中push值（一个或者多个），list不存在 lpushx失败
- **Lists 查找操作**
- lindex key index： 通过索引获取列表元素
- **Lists 删除操作**
- lpop/rpop key： 从最左边/最右边移除值 并返回
- **Hashs 添加操作**
- hset key field value： 将哈希表 key 中的字段 field 的值设为 value。重复设置同一个field会覆盖,返回0
- **Hashs 查找操作**
- hget key field value： 获取存储在哈希表中指定字段的值
- **Hashs 删除操作**
- hdel key field1 [field2…]： 删除哈希表key中一个/多个field字段

# redis 移除一个键的过期时间，用哪个命令？

**`persist`**

# redis的管道有什么用？怎么用？

一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应，这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。

这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。

# redis 怎么批量删除key？

```bash
./redis-cli -h 127.0.0.1 -p 6379 keys "java_suisui*" | xargs ./redis-cli -h 127.0.0.1 -p 6379 del
```

需要注意两点：

- 先根据通配符*查询出需要删除的key
- xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。通过xargs命令，将前面查询出来的key作为后面redis的del命令的输入。

# 假如 Redis 里面有 1 亿个 key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？

使用 keys 指令可以扫出指定模式的 key 列表。 

对方接着追问：如果这个 redis 正在给线上的业务提供服务，那使用keys 指令会有什么问题？ 

这个时候你要回答 redis 关键的一个特性：redis 的单线程的。keys 指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan 指令可以无阻塞的提取出指定模式的 key 列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys 指令长。

# redis的过期策略有哪些？

## 定时删除

在设置键的过期时间的同时，创建一个定时器（Timer），让定时器在key过期的时候删除key。

### 优点

内存友好

### 缺点

cpu不友好。

创建一个定时器需要Redis服务器中的时间事件，而当前时间事件的实现方式是无序列表，查找一个事件的时间的复杂度是O(N)，非常低效。

## 惰性删除

每次获取key的时候（get key）检查key是否过期，如果已经过期就删除该key，并返回null。

### 优点

对cpu最友好

### 缺点

内存不友好，容易造成内存泄漏（内存中存在大量已过期的key）

## 定期删除

每隔一段时间，对数据库进行一次检查，删除过期键。至于要删多少过期键，以及要检查多少个数据库，由算法决定。

### 优点

算是一种折中的方案，不会对cpu和内存太不友好。

### 缺点

需要根据情况，来合理地设置删除操作的执行时长与频率。

过于频繁会退化为定时删除。

执行次数太少又会出现内存浪费的情况。

# redis采用的哪种过期策略？

redis服务器实际使用的是 惰性删除 跟 定期删除两种策略。

# 什么是LRU？

Least Recently Used。（最近最少使用）

淘汰很久没被访问过的数据。

可以看作是一个头插链表，当Get某个节点的时候，会把Get的节点移动到头部。（LinkedHashMap）

淘汰的时候，从尾部删除。

# 什么是LFU？

Least Frequently(经常地，频繁地) used。（最不经常使用）

淘汰最近一段时间被访问次数最少的数据，以次数作为参考。

## 优点

一般情况下，LFU效率要优于LRU，能够避免周期性或者偶发性的操作导致缓存命中率下降的问题。

## 缺点

复杂度较高：需要额外维护一个队列或双向链表，复杂度较高

对新缓存不友好：新加入的缓存容易被清理掉，即使可能会被经常访问

# redis的内存淘汰策略

当Redis已用内存超过maxmemory限定时，触发主动清理策略主动清理策略在Redis 4.0之前一共实现了 6 种内存淘汰策略，在 4.0 之后，又增加了 2 种策略，总共8种:

**a)针对设置了过期时间的key做处理:**

volatile-lru：从设置了过期时间的键空间中，移除最近最少使用的key。

volatile-lfu：从设置了过期时间的键空间中，移除使用频率最少的键

volatile-random：从设置了过期时间的键空间中，随机移除某个key。

volatile-ttl：从设置了过期时间的键空间中，移除马上要过期的key。

**b)针对所有的key做处理:**

allkeys-lru：从所有键中移除最近最少使用的key。

allkeys-lfu：从所有键中移除使用频率最少的key。

allkeys-random：从所有键中随机移除某个key。

**c) 不处理:**

 no-enviction：不进行内存淘汰，当内存不足以容纳新写入数据时，新写入操作会报错。



# redis持久化

## RDB（Redis DataBase）

Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。

触发RDB持久化过程分为**手动触发**和**自动触发**。

默认的持久化方式。

对 Redis 中的数据执⾏周期性的持久化。

RDB更适合做冷备。

### 手动触发

手动触发有两种方式`save`和`bgsave`命令：

1. `save` 命令：：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。
2. `bgsave` 命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。**阻塞只发生在fork阶段**，一般时间很短。

显然bgsave命令是针对save阻塞问题做的优化。因此Redis内部所有的涉及RDB的操作都采用bgsave的方式，而save命令已经废弃。

### 自动触发

使用save相关配置，如`save m n`。表示m秒内数据集存在n次修改时，自动触发bgsave。

如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点。

执行debug reload命令重新加载Redis时，也会自动触发save操作。

默认情况下执行shutdown命令时，如果**没有开启AOF持久化功能**则自动执行bgsave。

### 优点

**RDB**对**Redis**的性能影响非常小。

数据恢复的时候速度比**AOF**快。

### 缺点

**RDB**都是快照文件，默认五分钟生成一个快照。**AOF**则最多丢一秒的数据。

**RDB**在生成数据快照的时候，如果文件很大，对客户端的读写会有影响。Redis有两个命令可以生成RDB文件，一个是SAVE，另一个是BGSAVE。SAVE命令会阻塞Redis服务器进程。BGSAVE会派生一个子进程，由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。

##  AOF

对每条写⼊命令作为⽇志，以 **append-only** 的模式写⼊⼀个⽇志⽂件中，在 Redis 重启的时候，可以通过回放 AOF ⽇志中的写⼊指令来重新构建整个数据集。

AOF更适合做热备。

在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：

```bash
appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显式地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步
```

默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，建议开启。建议持久化方式为 **appendfsync everysec**。

### 优点

可读性较好。

一秒同步一次，实时性更好。

写入快。

### 缺点

相同的数据，AOF文件要比RDB文件大

## RDB和AOF混合持久化（其实也是aof的一种）

Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 `aof-use-rdb-preamble` 开启）。

如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。

### 优点

可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。

### 缺点

AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。

## 线上redis持久化一般怎么配置？

如果对性能要求较高，在Master最好不要做持久化，可以在某个Slave开启AOF（RDB和AOF混合持久化）备份数据，策略设置为每秒同步一次即可。

## bgsave是怎么做到不阻塞正常业务读写的同时还能保证与内存数据一致的？

Redis 借助操作系统提供的写时复制技术(Copy-On-Write,COW)，在生成快照的同时，依然可以正常处理写命令。简单来说bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作，那么，主线程和 basave 子进程相互不影响。但是，如果主线程要修改块数据，那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。

# 如何发现redis中的bigkey？

**使用 Redis 自带的 `--bigkeys` 参数来查找。**

**分析 RDB 文件**

# 缓存穿透、击穿、雪崩

[CSDN Redis:缓存穿透、缓存击穿、缓存雪崩](https://blog.csdn.net/u011552171/article/details/108612299)

# redis支持的Java客户端有哪些？springboot用的哪种？

Jedis、lettuce、redisson。

Spring Boot 1.x 版本默认使用的是 Jedis ，而在 Spring Boot 2.x 版本默认使用的是Lettuce。

# MySQL与redis双写一致性如何保证？

## 三种经典的缓存模式

### Cache-Aside Pattern（旁路缓存模式）

Cache-Aside Pattern，即**旁路缓存模式**。

读流程：

- 先读缓存，如果命中缓存则直接返回。
- 如果没命中缓存，需要读数据库，并将数据库数据写入缓存，并返回数据。

写流程：

- 先更新数据库，后删除缓存。

### Read-Through/Write-Through（读写穿透）

**Read/Write-Through**模式中，服务端**把缓存作为主要数据存储**。应用程序跟数据库缓存交互，都是通过抽象缓存层完成的。

**Read-Through**实际只是在**Cache-Aside**之上进行了一层封装（在应用程序与缓存之间多了一层**Cache-Provider**），它会让程序代码变得更简洁，同时也减少数据源上的负载。

读流程：

- 先读缓存，如果命中缓存则直接返回。
- 如果没命中缓存，需要读数据库，并将数据库数据写入缓存，再从缓存中查询出数据并返回。

写流程：

- 先更新数据库，后更新缓存。

### Write-behind （异步缓存写入）

**Write-behind** 跟**Read-Through/Write-Through**有相似的地方，都是由**Cache Provider**来负责缓存和数据库的读写。它们又有个很大的不同：Read/Write-Through是同步更新缓存和数据的，Write-Behind则是只更新缓存，不直接更新数据库，通过**批量异步**的方式来更新数据库。

这种方式下，缓存和数据库的一致性不强，**对一致性要求高的系统要谨慎使用**。但是它适合频繁写的场景，MySQL的**InnoDB Buffer Pool**机制就使用到这种模式。

读流程：

- 先读缓存，如果命中缓存则直接返回。
- 如果没命中缓存，需要读数据库，并将数据库数据写入缓存，再从缓存中查询出数据并返回。

写流程：

- 先更新缓存，不马上更新数据库，而是通过批量异步的方式更新数据库。

## 写库的时候应该是删缓存还是更新缓存？

如果是更新缓存的话，并发写入的时候可能会造成数据库跟缓存数据不一致。所以写库应该是删除缓存。

考虑以下场景，会造成数据不一致：

1. 线程A发起一个写库操作，先更新了数据库。

2. 线程B发起一个写库操作，更新了数据库。

3. 由于网络原因线程B先更新了缓存。

4. 线程A后更新缓存。

## 双写时是先写数据库？还是先删缓存？

先删缓存，后写数据库。

考虑以下场景（先删缓存后写数据库），会造成数据不一致：

1. 线程A发起一个写操作，第一步del cache
2. 此时线程B发起一个读操作，cache miss
3. 线程B继续读DB，读出来一个老数据
4. 然后线程B把老数据设置入cache
5. 线程A写入DB最新的数据

总结一下上面的逻辑：在线程A删缓存与写库之间，线程B读数据，就会把旧的mysql数据放到缓存里。

## 先写数据库，后删缓存就不会有问题么？

会有问题的。写库操作与删缓存操作无法保证原子性。（假如删redis时候没有删掉，redis宕机了，这种情况概率很小）

考虑以下场景，会造成数据不一致：

1. 线程A发起一个写请求，写DB，还未删缓存
2. 线程B发起一个读请求，读缓存中的数据（脏数据），此时缓存中的数据已经跟DB中的数据不一致
3. 线程A删缓存

再考虑以下场景，会造成数据不一致：

1. 线程A发起一个写请求，写DB，删缓存（方法上有事务），方法未执行完（DB事务没有提交）
2. 线程B发起读请求，查询DB数据，并放到缓存里（这时候的DB数据是未提交前的数据）
3. 线程A提交事务

## 四种方案保证数据库与缓存的最终一致性

### 延时双删

延时双删写流程：

1. 先删除缓存
2. 再更新数据库
3. 发个延时消息（读业务逻辑数据的耗时 + 几百毫秒 = 大概1s），删除缓存。

这种方案只有1s左右的时间可能会有脏数据，一般业务可以接受。

考虑：如果删除缓存失败了ne？给key设置一个过期时间，让他自动过期。

### 删除缓存失败-重试机制

删除缓存重试流程：

1. 写请求更新数据库
2. 缓存因为某些原因，删除失败，业务catch异常
3. 把删除失败的key放到消息队列
4. 消费消息队列的消息，获取要删除的key
5. 重试删除缓存操作

### 读取binlog异步删除缓存

流程：

通过Canal监听binlog，发送到MQ，消费者处理删除、更新的binlog，删除相应的缓存数据。

### 分布式锁

在所有操作数据库与缓存的接口上添加分布式锁。串行执行解决数据不一致问题。

但是 性能较低。

# Redis 有哪些适合的场景？

## 会话缓存（Session Cache）

 最常用的一种使用 Redis 的情景是会话缓存（sessioncache），用Redis 缓存会话比其他存储（如 Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？ 幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis 来缓存会话的文档。甚至广为人知的商业平台 Magento 也提供 Redis 的插件。

## 全页缓存（FPC） 

数据缓存。

## 队列 

Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。 如果你快速的在 Google 中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用 Redis 创建非常好的后端工具，以满足各种队列需求。例如，Celery 有一个后台就是使用 Redis 作为 broker，你可以从这里去查看。

## 排行榜/计数器

Redis 在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（SortedSet）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。 所以，我们要从排序集合中获取到排名最靠前的 10 个用户，我们称之为“user_scores”，我们只需要像下面一样执行即可： 当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行： ZRANGE user_scores 0 10 WITHSCORES Agora Games 就是一个很好的例子，用 Ruby 实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。 

## 发布/订阅

最后（但肯定不是最不重要的）是 Redis 的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用 Redis 的发布/订阅功能来建立聊天系统！



# redis事务







# 一次线上事故，Redis主从切换导致了缓存雪崩

我们假设，slave 的机器时钟比 master 走得快很多此时，Redis master里设置了过期时间的key，从 slave 角度来看，可能会有很多在 master 里没过期的数据其实已经过期了。

如果此时操作主从切换，把 slave 提升为新的 master。它成为 master 后，就会开始大量清理过期 key，此时就会导致以下结果:

- 1.master 大量清理过期 key，主线程可能会发生阻塞，无法及时处理客户端请求。
- 2.Redis 中数据大量过期，引发缓存雪崩。

当 master与slave 机器时钟严重不一致时，对业务的影响非常大。
所以，我们一定要保证主从库的机器时钟一致性，避免发生这些问题























