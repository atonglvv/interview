# 为什么要用缓存？

高性能：缓存快

高并发：MySQL也就2000QPS，缓存可以支持十几万QPS

# 什么是缓存预热？

缓存预热就是系统上线后，将相关的缓存数据直接加载到缓存系统。避免用户请求的时候， 先查询数据库，然后再将数据缓存的问题！

# 用缓存后有什么问题？

数据库与缓存的一致性问题

缓存会有击穿、穿透、雪崩的问题

# redis除了做缓存，还能做什么？

- 分布式锁
- 限流：redis+Lua
- 消息队列
- 复杂业务场景：统计活跃用户（bitmap），排行榜（sorted set）

# redis 的线程模型

**Redis 基于 Reactor 模式（Netty的线程模型也是基于Reactor模式）来设计开发了自己的一套高效的事件处理模型** 。

redis的文件事件处理器（file event handler）是单线程方式运行的，所以一般我们都说Redis是单线程模型。

# 为什么之前的redis是单线程也能有这么高的效率？

Redis 通过**IO 多路复用程序** 来监听来自客户端的大量连接（或者说是监听多个 socket）。

这样的好处非常明显： **I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗**（和 NIO 中的 `Selector` 组件很像）。

高效的数据存储结构。

# redis6.0之前为什么不用多线程？

- 单线程编程容易并且更容易维护；
- Redis 的性能瓶颈不在 CPU ，主要在内存和网络；
- 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。

# redis 为什么后面引入了多线程？

**Redis6.0 引入多线程主要是为了提高网络 IO 读写性能**。Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此不需要担心线程安全问题。

Redis6.0 的多线程默认是禁用的，只使用主线程。

# 为什么redis这么快？

IO多路复用

内存

单线程不需要处理并发问题，不需要线程切换

数据结构简单

# redis 有哪些数据类型？

Strings

Hashes

Lists

Sets

Sorted Sets

Redis 除了这 5 种数据类型之外，还有 Bitmaps、HyperLogLogs、 geospatial indexes  、Streams 等。

# redis 的常用命令

- keys * ：查看当前数据库中所有的key
- dbsize： 键总数
- exists key： 检查键是否存在
- del key [key …]： 删除键
- persist key： 移除键的过期时间
- type key： 键的数据结构类型
- set key value： 设置一个key的value值
- setnx key value： 仅当key不存在时进行set
- setex key seconds value： set 键值对并设置过期时间
- get key： 返回key的value
- mget key [key …] ： 批量获取多个key保存的值
- exists key [key …]： 查询一个key是否存在
- decr/incr key： 将指定key的value数值进行+1/-1(仅对于数字)
- incrby/decrbyB key n： 按指定的步长对数值进行加减
- **Lists 添加操作**
- lpush/rpush key value1[value2…]： 从左边/右边向列表中PUSH值(一个或者多个)
- lpushx/rpushx key value： 向已存在的列名中push值（一个或者多个），list不存在 lpushx失败
- **Lists 查找操作**
- lindex key index： 通过索引获取列表元素
- **Lists 删除操作**
- lpop/rpop key： 从最左边/最右边移除值 并返回
- **Hashs 添加操作**
- hset key field value： 将哈希表 key 中的字段 field 的值设为 value。重复设置同一个field会覆盖,返回0
- **Hashs 查找操作**
- hget key field value： 获取存储在哈希表中指定字段的值
- **Hashs 删除操作**
- hdel key field1 [field2…]： 删除哈希表key中一个/多个field字段

# redis 移除一个键的过期时间，用哪个命令？

**`persist`**

# redis 怎么批量删除key？

```bash
./redis-cli -h 127.0.0.1 -p 6379 keys "java_suisui*" | xargs ./redis-cli -h 127.0.0.1 -p 6379 del
```

需要注意两点：

- 先根据通配符*查询出需要删除的key
- xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。通过xargs命令，将前面查询出来的key作为后面redis的del命令的输入。

# redis的过期策略有哪些？

## 定时删除

在设置键的过期时间的同时，创建一个定时器（Timer），让定时器在key过期的时候删除key。

### 优点

内存友好

### 缺点

cpu不友好。

创建一个定时器需要Redis服务器中的时间事件，而当前时间事件的实现方式是无序列表，查找一个事件的时间的复杂度是O(N)，非常低效。

## 惰性删除

每次获取key的时候（get key）检查key是否过期，如果已经过期就删除该key，并返回null。

### 优点

对cpu最友好

### 缺点

内存不友好，容易造成内存泄漏（内存中存在大量已过期的key）

## 定期删除

每隔一段时间，对数据库进行一次检查，删除过期键。至于要删多少过期键，以及要检查多少个数据库，由算法决定。

### 优点

算是一种折中的方案，不会对cpu和内存太不友好。

### 缺点

需要根据情况，来合理地设置删除操作的执行时长与频率。

过于频繁会退化为定时删除。

执行次数太少又会出现内存浪费的情况。

# redis采用的哪种过期策略？

redis服务器实际使用的是 惰性删除 跟 定期删除两种策略。

# 什么是LRU？

Least Recently Used。

可以看作是一个头插链表，当Get某个节点的时候，会把Get的节点移动到头部。（LinkedHashMap）

淘汰的时候，从尾部删除。

# 什么是LFU？

Least Frequently(经常地，频繁地) used。

## 优点

一般情况下，LFU效率要优于LRU，能够避免周期性或者偶发性的操作导致缓存命中率下降的问题

## 缺点

复杂度较高：需要额外维护一个队列或双向链表，复杂度较高

对新缓存不友好：新加入的缓存容易被清理掉，即使可能会被经常访问

# redis的内存淘汰策略

 no-enviction：不进行内存淘汰，当内存不足以容纳新写入数据时，新写入操作会报错。

allkeys-lru：从所有键中移除最近最少使用的key。

allkeys-lfu：从所有键中移除使用频率最少的key。

allkeys-random：从所有键中随机移除某个key。

volatile-lru：从设置了过期时间的键空间中，移除最近最少使用的key。

volatile-lfu：从设置了过期时间的键空间中，移除使用频率最少的键

volatile-random：从设置了过期时间的键空间中，随机移除某个key。

volatile-ttl：从设置了过期时间的键空间中，移除马上要过期的key。

# redis持久化

## RDB（Redis DataBase）

Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。

触发RDB持久化过程分为**手动触发**和**自动触发**。

默认的持久化方式。

对 Redis 中的数据执⾏周期性的持久化。

RDB更适合做冷备。

### 手动触发

手动触发有两种方式`save`和`bgsave`命令：

1. `save` 命令：：阻塞当前Redis服务器，直到RDB过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。
2. `bgsave` 命令：Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。**阻塞只发生在fork阶段**，一般时间很短。

显然bgsave命令是针对save阻塞问题做的优化。因此Redis内部所有的涉及RDB的操作都采用bgsave的方式，而save命令已经废弃。

### 自动触发

使用save相关配置，如`save m n`。表示m秒内数据集存在n次修改时，自动触发bgsave。

如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点。

执行debug reload命令重新加载Redis时，也会自动触发save操作。

默认情况下执行shutdown命令时，如果**没有开启AOF持久化功能**则自动执行bgsave。

### 优点

**RDB**对**Redis**的性能影响非常小。

数据恢复的时候速度比**AOF**快。

### 缺点

**RDB**都是快照文件，默认五分钟生成一个快照。**AOF**则最多丢一秒的数据。

**RDB**在生成数据快照的时候，如果文件很大，对客户端的读写会有影响。Redis有两个命令可以生成RDB文件，一个是SAVE，另一个是BGSAVE。SAVE命令会阻塞Redis服务器进程。BGSAVE会派生一个子进程，由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求。

##  AOF

对每条写⼊命令作为⽇志，以 **append-only** 的模式写⼊⼀个⽇志⽂件中，在 Redis 重启的时候，可以通过回放 AOF ⽇志中的写⼊指令来重新构建整个数据集。

AOF更适合做热备。

在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：

```bash
appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显式地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步
```

默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，建议开启。建议持久化方式为 **appendfsync everysec**。

### 优点

可读性较好。

一秒同步一次，实时性更好。

写入快。

### 缺点

相同的数据，AOF文件要比RDB文件大

## RDB和AOF混合持久化

Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 `aof-use-rdb-preamble` 开启）。

如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。

### 优点

可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。

### 缺点

AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。

# 如何发现redis中的bigkey？

**使用 Redis 自带的 `--bigkeys` 参数来查找。**

**分析 RDB 文件**

# 缓存穿透、击穿、雪崩

[CSDN Redis:缓存穿透、缓存击穿、缓存雪崩](https://blog.csdn.net/u011552171/article/details/108612299)

# redis支持的Java客户端有哪些？springboot用的哪种？

Jedis、lettuce、redisson。

Spring Boot 1.x 版本默认使用的是 Jedis ，而在 Spring Boot 2.x 版本默认使用的是Lettuce。

# MySQL与redis双写一致性如何保证？

## 三种经典的缓存模式

### Cache-Aside Pattern

Cache-Aside Pattern，即**旁路缓存模式**。

读流程：

- 先读缓存，如果命中缓存则直接返回。
- 如果没命中缓存，需要读数据库，并将数据库数据写入缓存，并返回数据。

写流程：

- 先更新数据库，后删除缓存。

### Read-Through/Write-Through（读写穿透）

**Read/Write-Through**模式中，服务端**把缓存作为主要数据存储**。应用程序跟数据库缓存交互，都是通过抽象缓存层完成的。

**Read-Through**实际只是在**Cache-Aside**之上进行了一层封装（在应用程序与缓存之间多了一层**Cache-Provider**），它会让程序代码变得更简洁，同时也减少数据源上的负载。

读流程：

- 先读缓存，如果命中缓存则直接返回。
- 如果没命中缓存，需要读数据库，并将数据库数据写入缓存，再从缓存中查询出数据并返回。

写流程：

- 先更新数据库，后更新缓存。

### Write-behind （异步缓存写入）

**Write-behind** 跟**Read-Through/Write-Through**有相似的地方，都是由**Cache Provider**来负责缓存和数据库的读写。它们又有个很大的不同：Read/Write-Through是同步更新缓存和数据的，Write-Behind则是只更新缓存，不直接更新数据库，通过**批量异步**的方式来更新数据库。

这种方式下，缓存和数据库的一致性不强，**对一致性要求高的系统要谨慎使用**。但是它适合频繁写的场景，MySQL的**InnoDB Buffer Pool**机制就使用到这种模式。

读流程：

- 先读缓存，如果命中缓存则直接返回。
- 如果没命中缓存，需要读数据库，并将数据库数据写入缓存，再从缓存中查询出数据并返回。

写流程：

- 先更新缓存，不马上更新数据库，而是通过批量异步的方式更新数据库。

## 写库的时候应该是删缓存还是更新缓存？

如果是更新缓存的话，并发写入的时候可能会造成数据库跟缓存数据不一致。所以写库应该是删除缓存。

考虑以下场景，会造成数据不一致：

1. 线程A发起一个写库操作，先更新了数据库。

2. 线程B发起一个写库操作，更新嘞数据库。

3. 由于网络原因线程B先更新了缓存。

4. 线程A后更新缓存。

## 双写时是先写数据库？还是先删缓存？

先写数据库，后删缓存。

考虑以下场景（先删缓存后写数据库），会造成数据不一致：

1. 线程A发起一个写操作，第一步del cache
2. 此时线程B发起一个读操作，cache miss
3. 线程B继续读DB，读出来一个老数据
4. 然后线程B把老数据设置入cache
5. 线程A写入DB最新的数据

总结一下上面的逻辑：在线程A删缓存与写库之间，线程B读数据，就会把旧的mysql数据放到缓存里。

## 先写数据库，后删缓存就不会有问题么？

会有问题的。写库操作与删缓存操作无法保证原子性。（假如删redis时候没有删掉，redis宕机了，这种情况概率很小）

考虑以下场景，会造成数据不一致：

1. 线程A发起一个写请求，写DB，还未删缓存
2. 线程B发起一个读请求，读缓存中的数据（脏数据），此时缓存中的数据已经跟DB中的数据不一致
3. 线程A删缓存

再考虑以下场景，会造成数据不一致：

1. 线程A发起一个写请求，写DB，删缓存（方法上有事务），方法未执行完（DB事务没有提交）
2. 线程B发起读请求，查询DB数据，并放到缓存里（这时候的DB数据是未提交前的数据）
3. 线程A提交事务

## 四种方案保证数据库与缓存的最终一致性

### 延时双删

延时双删写流程：

1. 先更新数据库
2. 再删除缓存
3. 发个延时消息（读业务逻辑数据的耗时 + 几百毫秒 = 大概1s），删除缓存。

这种方案只有1s左右的时间可能会有脏数据，一般业务可以接受。

考虑：如果删除缓存失败了ne？给key设置一个过期时间，让他自动过期。

### 删除缓存失败-重试机制

删除缓存重试流程：

1. 写请求更新数据库
2. 缓存因为某些原因，删除失败，业务catch异常
3. 把删除失败的key放到消息队列
4. 消费消息队列的消息，获取要删除的key
5. 重试删除缓存操作

### 读取binlog异步删除缓存

流程：

通过Canal监听binlog，发送到MQ，消费者处理删除、更新的binlog，删除相应的缓存数据。

### 分布式锁

在所有操作数据库与缓存的接口上添加分布式锁。串行执行解决数据不一致问题。

但是 性能较低。















































